---
description: Требуется идентифицировать узлы или сравнить их на основе позиции в документе
---

# Сравнение узлов

## Задача

Требуется идентифицировать узлы или сравнить их на основе позиции в документе.

## Решение

### XPath 1.0

В следующих примерах предполагается, что `$x` и `$y` содержат по одному узлу из одного и того же документа. Напомним также, что порядок документа – это тот порядок, в котором узлы следуют в документе.

Проверить, представляют ли переменные `$x` и `$y` один и тот же узел: `generate-id($x) = generate-id($y)`

Можно также воспользоваться тем фактом, что оператор `|` удаляет дубликаты: `count($x|$y) = 1`

Проверить, что `$x` предшествует `$y` в порядке документа. Отметим, что этот способ не работает, если `$x` или `$y` - атрибут: `count(($x/preceding::node()) < count(($y/preceding::node()) or $x = $y/ancestor::node()`

Проверить, что `$x` следует за `$y` в порядке документа. Отметим, что этот способ не работает, если `$x` или `$y` – атрибут: `count(($x/following::node()) < count(($y/following::node()) or $x = $y/ancestor::node()`

### XPath 2.0

Проверить, представляют ли переменные `$x` и `$y` один и тот же узел: `$x is $y`

Проверить, что `$x` предшествует `$y` в порядке документа: `$x << $y`

Проверить, что `$x` следует за `$y` в порядке документа: `$x >> $y`

## Обсуждение

Появившиеся в XPath 2.0 операторы сравнения узлов работают более эффективно и проще для понимания, чем конструкции из XPath 1.0. Однако при работе с XPath 2.0 ситуации, когда в этих операторах возникает необходимость, встречаются не так уж часто. Обычно, когда вам кажется, что нужно бы воспользоваться оператором `<<` или `>>`, задачу проще решить с помощью предложения `xsl::for-each-group`.
