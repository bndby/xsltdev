# Расширения EXSLT для работы со строками

## Задача

У вас есть основательные причины воспользоваться дополнительными функциями для обработки строк, но беспокоит вопрос переносимости.

## Решение

Не исключено, что ваш процессор XSLT уже реализует строковые функции, определенные сообществом [EXSLT](http://www.exslt.org). На момент работы над этой книгой в их число входили следующие функции.

```
node-set str::tokenize(string input, string delimiters?)
```

Функция `str::tokenize` разбивает строку на лексемы и возвращает набор узлов, состоящий из элементов `token`, каждый из которых содержит текст одной лексемы.

Первый аргумент – подлежащая разбиению строка. Второй аргумент – строка, содержащая символы-разделители. Строка, переданная в первом аргументе, разбивается в местах, где встречается любой символ-разделитель.

Если второй аргумент опущен, по умолчанию подразумевается строка `&#x9;&#xA;&#xD;&#x20;` (то есть все символы пропуска).

Если второй аргумент – пустая строка, то функция возвращает набор элементов `token`, каждый из которых содержит по одному символу.

```
node-set str::replace(string, object search, object replace)
```

Функция `str:replace` заменяет все вхождения искомых подстрок в исходную строку набором узлов замены, создавая набор узлов.

Первый аргумент – строка, в которой ищутся заменяемые подстроки.

Второй аргумент – объект, описывающий список искомых строк. Если он представляет собой набор узлов, то список искомых строк получается путем преобразования каждого узла в строку с помощью функции `string()`, причем порядок строк в списке определяется порядком узлов в документе. Если второй аргумент – не набор узлов, то он преобразуется в строку функцией `string()`, так что список искомых строк будет содержать всего одну строку.

Третий аргумент – объект, представляющий список узлов замены. Если это набор узлов, то список состоит из этих узлов, перечисленных в порядке документа. Если же это не набор узлов, то список узлов замены состоит из единственного текстового узла, строковое значение которого получается преобразованием третьего аргумента в строку функцией `string()`.

```
string str::padding(number, string?)
```

Функция `str::padding` создает строку заполнения заданной длины.

Первый аргумент – длина требуемой строки заполнения.

Второй аргумент – строка, на основе которой создается строка заполнения. Она повторяется столько раз, сколько необходимо для получения строки, длина которой задана первым аргументом. Если эта строка содержит более одного символа, то результат может быть обрезан для получения требуемой длины. Если второй аргумент опущен, по умолчанию подразумевается пробел (`""`). Если второй аргумент – пустая строка, то `str::padding` возвращает пустую строку.

```
string str::align(string, string, string?)
```

Функция `str::align` выравнивает одну строку в границах другой. Первый аргумент – строка, подлежащая выравниванию. Второй аргумент – строка заполнения, внутри которой выравнивается первая строка.

Если первая строка короче второй, то некоторые символы в строке заполнения заменяются символами из выравниваемой строки. Какие именно символы заменяются, зависит от значения третьего аргумента, определяющего способ выравнивания. Он может принимать значения `left`, `right` или `center`. Если третий аргумент опущен или не совпадает с одним из указанных значений, по умолчанию подразумевается `left`.

При выравнивании по левому краю диапазон символов, заменяемых выравниваемой строкой, начинается с первого символа строки заполнения. При выравнивании по правому краю диапазон символов, заменяемых выравниваемой строкой, заканчивается последним символом строки заполнения. При выравнивании по центру диапазон символов, заменяемых выравниваемой строкой, находится в середине строки заполнения, то есть число не замененных символов слева и справа от этого диапазона одинаково или слева на один символ меньше, чем справа. Если выравниваемая строка длиннее строки заполнения, то она обрезается до той же длины, что строка заполнения, и возвращается получившийся результат.

```
string str::encode-uri(string)
```

Функция `str:encode-uri` возвращает закодированный URI. При этом следующие символы не подвергаются кодированию: «`:`», «`/`», «`;`» и «`?`». При кодировании URI небезопасные и зарезервированные символы заменяются строкой, которая начинается с символа «`%`», за которым следуют две шестнадцатеричные цифры (`0-9`, `A-F`), представляющие значение символа в кодировке ISO Latin 1.

```
string str::decode-uri(string)
```

Функция `str:decode-uri` раскодирует строку, содержащую закодированный URI. См. описание функции `str:encode-uri`.

```
node-set str::concat(node-set)
```

Функция `str:concat` принимает набор узлов и возвращает строку, получающуюся в результате конкатенации строковых значений этих узлов. Если набор узлов пуст, возвращается пустая строка.

```
node-set str::split(string, string?)
```

Функция `str:split` разбивает строку и возвращает набор узлов, состоящий из элементов `token`, каждый из которых содержит одну лексему. Первый аргумент – подлежащая разбиению строка, второй – строка-образец. Первая строка разбивается в местах, где обнаруживается текст, сопоставившийся с образцом.

Если второй аргумент опущен, по умолчанию принимается строка `&#x20` (пробел).

Если второй аргумент – пустая строка, то функция возвращает набор элементов `token`, каждый из которых содержит ровно один символ.

## Обсуждение

Если вы пользуетесь строковыми функциями EXSLT, то переносимость не гарантируется, поскольку в настоящий момент ни одна реализация XSLT не поддерживает их все. Более того, на сайте EXSLT говорится, что для некоторых функций пока нет вообще ни одной реализации. Сообщество EXSLT компенсирует это, предоставляя, когда возможно, реализации на чистом XSLT, JavaScript или MSXML.

Убедительной причиной пользоваться расширениями EXSLT является тот факт, что члены этого коллектива играют весьма заметную роль в сообществе XSLT, поэтому многие реализации равно или поздно будут поддерживать большую часть предлагаемых расширений. Не исключено также, что их работа хотя бы отчасти войдет в стандарт следующей версии XSLT.
