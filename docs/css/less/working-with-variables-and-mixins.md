# Работа с переменными и примесями

Чтобы компилятор выполнял хоть сколько-нибудь полезные действия, интерпретируя JavaScript-код — ему нужны значения, которые он может получить из переменных. Для того, чтобы получить значения переменных, необходимо использовать один из представленных ниже вариантов синтаксиса:

```less
.test-js {
  @test: 123;
  content: ` @{test}`;
  content: `this.test.toJS() `;
}
```

Оба варианта хорошо работают с локальными переменными. С глобальными переменными работает лишь первый способ, так как `this`, во втором случае, явно указывает на контекст, то есть селектор. Без контекста `test.toJS()` работать не будет.

Результатом компиляции будет:

```css
.test-js {
  content: 123;
  content: '123';
}
```

Далее я приведу несколько примеров работы с переменными, используя JavaScript-код в Less:

```less
.test-js {
  // Интерполяция
  @world: 'world';
  content: ~` 'hello' + ' ' + @{world}`;

  // Списки
  @list: 1, 2, 3;
  @list-js: ~` @{list}.join(', ') `;
  content: @list-js;
}
```

Компилятор создаст два свойства `content` и присвоит им вполне валидные значения:

```css
.test-js {
  content: hello world;
  content: 1, 2, 3;
}
```

Первый пример демонстрирует возможность интерполяции строк прямиком в JavaScript, второй — работу со списками.

Немного подробнее остановимся на списках. Ранее я уже говорил, что списки — это альтернатива массивам в JavaScript. Списки в Less можно итерировать и узнавать их длину. Тот список, что определён в переменной `@list` никаких вопросов не вызывает:

```less
.test-js {
  @list: 1, 2, 3;
  content: length(@list);
  content: extract(@list, 1);
}

// На выходе получаем
.test-js {
  content: 3; // Длина
  content: 1; // Первый элемент массива
}
```

А вот значение переменной `@list-js` списком не является, так как на выходе JavaScript-кода всегда находится строка:

```less
.test-js {
  @list: 1, 2, 3;
  @list-js: ~` @{list}.join(', ') `;
  content: length(@list-js);
  content: extract(@list-js, 1);
}

// На выходе получаем
.test-js {
  content: 1; // Длина
  content: 1, 2, 3; // Первый элемент массива
}
```

## Примеси

Наиболее очевидным применением возможностей JavaScript-кода в Less является создание примесей, которые на вход получают какое-то количество переменных, обрабатывают их, используя JavaScript и возвращают строку, как результат.

### Конечное число переменных

Самым простым способом получить значения из переменных в Less является следующая функция:

```js
;(function (a, b) {
  return a + b
})('@{a}', '@{b}')
```

Используя обёртку в виде примеси, её можно представить в удобном для использования виде:

```less
.mixin(@a, @b) {
  @js: ~`(function(a, b) {return a + b;}) ('@{a}', '@{b}') `;

  content: @js;
}

.test-js {
  .mixin(1, 2);
}
```

Результатом компиляции будет являться сумма двух чисел, переданных, как аргументы примеси `.mixin()`:

```css
.test-js {
  content: 12;
}
```

### Неопределённое число переменных

Если для проведения операций в выражении требуется большое количество переменных, или их количество неизвестно заранее, то на помощь приходит следующая функция, возвращающая массив всех переданных аргументов:

```js
;(function (args) {
  return args
})('@{arguments}')
```

Записывая эту функцию в переменную и используя примесь, у которой на вход подаётся переменное количество аргументов, получим следующий less-код:

```less
.mixin(...) {
  @js: ~`(function(args){return args;}) ('@{arguments}') `;

  content: @js;
}

.test-js {
  .mixin(3, 123);
}
```

И, как я уже сказал, после компиляции будет доступен массив всех переданных значений:

```css
.test-js {
  content: [3, 123];
}
```

В Less с таким результатом сделать ничего не получится (мешают квадратные скобки), поэтому на практике лучше всего использовать следующую модификацию предложенной функции:

```js
;(function (args) {
  return args
})(
  (function () {
    var args = '@{arguments}'
    return args.replace(/^\[|\]$/g, '')
  })()
)
```

Этот вариант записи удаляет квадратные скобки, используя метод `replace()`, при этом делая получаемый на выходе массив немного лучше:

```less
.mixin(...) {
  @js: ~`function(args){return args }(
      function(){var args= '@{arguments}' ;return args.replace(/ ^\[|\]$/g, '') }(

        )
    ) `;

  content: @js;
}

.test-js {
  .mixin(3, 123);
}
```

К сожалению, как я и показывал ранее — массив преобразуется в строку, содержимое которой нельзя итерировать.

```css
.test-js {
  content: 3, 123;
}
```

## Преобразование значений

Конечно, на практике мало пользы от того, что вы можете получить, распарсить и отдать результат обратно — необходимо с ним как-то взаимодействовать.

В приведённом ниже примере последнему в списке значению добавляется единица измерения `deg`:

```js
;(function (args) {
  return (
    (args = args || '0, 0, 0, 0'),
    (args = args.replace(/,\s*\d+$/, function (args) {
      return args + 'deg'
    }))
  )
})(
  (function () {
    var args = '@{arguments}'
    return (args = args.replace(/^\[|\]$/g, ''))
  })()
)
```

В итоге примесь имеет вид:

```less
.rotate3d(...) {
  @js: ~`(
      function(args) {return args = args || '0, 0, 0, 0',
      args = args.replace(/, \s* \d+ $/, function(args) {return args + 'deg'})}
    ) (
      (
          function() {var args = '@{arguments}' ; return args = args.replace(
              / ^\[|\]$/g,
              ''
            )}
        )
        ()
    ) `;

  transform: rotate3d(@js);
}

.test-js {
  .rotate3d(1, 0, 0, 50);
}
```

После компиляции получится отформатированное значение свойства `transform`:

```css
.test-js {
  transform: rotate3d(1, 0, 0, 50deg);
}
```

Если вызвать эту же примесь без аргументов, то будет выводиться результат по умолчанию, то есть нули:

```css
.test-js {
  transform: rotate3d(0, 0, 0, 0deg);
}
```

> Описанные в этой главе примеры доступны под номерами 6.1.1 - 6.1.4 и работают только с компиляторами, написанными на JavaScript.

## Выводы и мысли

Да, Less умеет интерпретировать JavaScript-код, записанный в переменной или в значении свойства, но получаемая от этого польза слишком мала и не покрывает потраченных на это усилий. Используя JavaScript в Less вы загрязняете его и усложняете для восприятия.
