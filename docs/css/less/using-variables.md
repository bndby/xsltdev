# Использование переменных

В любом полноценном языке программирования есть **переменные** (от англ. variables), которые представляют собой именованную область памяти и позволяют записывать в себя какие-либо данные. Переменные дают возможность обращаться к себе по имени, а также изменять присвоенные им значения.

Переменные, имеющие заранее заданный тип данных, с которым они могут работать, называют _типизированными_. Такие переменные могут работать только с данными заданного типа и, если попытаться присвоить значение другого типа, то нас будет ожидать ошибка компиляции. Соответственно, если переменным можно присваивать значения любого типа, то их называют _динамическими_.

Процесс объявления (определения) переменных и присваивания им значения называют _инициализацией_.

Обычно, переменные _переопределяемые_, то есть при инициализации в них можно записать значение и, по ходу работы программы, изменять его столько раз, сколько нужно разработчику. К сожалению, существуют переменные с неизменяемыми значениями — _непереопределяемые_.

В Less переменные динамические, переопределяемые и требующие инициализации.

Любая переменная в Less инициализируется как директива, то есть с использованием символа собачки (@) в начале.

```less
@block-background: #f5f5f5;
@block-color: #333;
@block-border-color: #ddd;
```

Для того, чтобы использовать значение переменной при написании кода, необходимо её вызвать. Делается это так:

```less
.block {
  background-color: @block-background;
  color: @block-color;
  border: 1px solid @block-border-color;
}
```

## Хранение данных

В переменных можно хранить любые данные, которые подходят под шаблон `@name: value;`. Для примера я подобрал несколько значений, которые можно присвоить переменным:

```less
@var-color: #ffff00;
@var-string-0: header;
@var-string-1: 0 auto;
@var-number: 4768;
@var-value: 14px;
@var-rule: {
  color: red;
};
@var-url-0: '../images/nichosi-meme.png';
@var-url-1: url('../images/nichosi-meme.png');
```

## Операции с переменными (операторы)

Оператором называется нечто, принимающее одно или более значений (или выражений, если говорить на жаргоне программирования), и вычисляющее новое значение (таким образом, вся конструкция может рассматриваться как выражение).

В Less присутствует два режима интерпретации операций с выражениями: обычный и строгий.

**Арифметические операции (обычный режим)**

Допускается производить операции с выражениями, значения которых соответствуют строкам.

|  Пример  | Название  |          Результат          | Числа |     Строки     |
| :------: | :-------: | :-------------------------: | :---: | :------------: |
|   -@a    | Отрицание |       Смена знака @a        |   +   |     ошибка     |
| @a + @b  | Сложение  |        Сумма @a и @b        |   +   | игнорируется\* |
| @a - @b  | Вычитание |      Разность @a и @b       |   +   | игнорируется\* |
| @a \* @b | Умножение |    Произведение @a и @b     |   +   | игнорируется\* |
| @a / @b  |  Деление  | Частное от деления @a на @b |   +   | игнорируется\* |

<sup>\*</sup> — игнорируется при условии, что производится операция с явно указанной строкой в выражении не через переменную, а напрямую. Иначе ошибка.

**Арифметические операции (строгий режим)**

Для включения строгого режима арифметических операций нужно взять выражения в круглые скобки `(выражение)`. В таком режиме запрещается производить операции со строками.

|   Пример   | Название  |          Результат          | Числа | Строки |
| :--------: | :-------: | :-------------------------: | :---: | :----: |
|   (-@a)    | Отрицание |       Смена знака @a        |   +   | ошибка |
| (@a + @b)  | Сложение  |        Сумма @a и @b        |   +   | ошибка |
| (@a - @b)  | Вычитание |      Разность @a и @b       |   +   | ошибка |
| (@a \* @b) | Умножение |    Произведение @a и @b     |   +   | ошибка |
| (@a / @b)  |  Деление  | Частное от деления @a на @b |   +   | ошибка |

Перечисленные в таблицах операции можно производить с числами, строками, цветами и числами с указанной размерностью. Ниже представлена таблица, демонстрирующая операцию и её результат с различными входными данными.

|   @a    |  @b  | @a + @b | @a - @b |   @a \* @b   |   @a / @b    |
| :-----: | :--: | :-----: | :-----: | :----------: | :----------: |
|    1    |  1   |    2    |    0    |      1       |      1       |
|   1px   |  2   |   3px   |  -1px   |     2px      |    0.5px     |
|   5%    |  4   |   9%    |   1%    |     20%      |    1.25%     |
|   2%    | 3px  |   5%    |   -1%   |      6%      | 0.6666..66%  |
|  0.33   | 11%  | 11.33%  | -10.67% | 3.6300...03% | 0.0300...02% |
| #6699cc | 25%  | #6b9ed1 | #6194c7 |   #ffffff    |   #141f29    |
|  #666   | #333 | #999999 |  #333   |   #ffffff    |   #020202    |

## Экранирование

**Экранирование** — это замена управляющих символов на соответствующие текстовые подстановки. Делается это для того, чтобы использовать некоторые строковые конструкции в рамках языка, которые компилятор может принять за конструкции самого языка.

В Less такой опасной конструкцией могут стать фильтры, которые для IE часто принимают вид:

```less
.element {
  filter: ms:alwaysHasItsOwnSyntax.For.Stuff();
}
```

Если попытаться скомпилировать этот блок кода, компилятор будет нарываться на ошибку и любезно сообщать её нам:

```shell
$ lessc _styles.less > styles.css

ParseError: Unrecognised input in _styles.less on li ne 24, column 13:

23 .element {
24   filter: ms:alwaysHasItsOwnSyntax.For.Stuff();
25 }
```

Разумеется, ничего хорошего из этого не выйдет, но решение этой проблемы, как гласит название раздела — _экранирование_.

Экранирование в Less может осуществляться двумя способами. Первый путь подразумевает под собой использование функции `e()`, а второй — синтаксической конструкции `~""` или `~''`. Оба способа ожидают на входе строку, окружённую кавычками, которые при компиляции будут удалены.

```less
.element {
  filter: e('ms:alwaysHasItsOwnSyntax.For.Stuff()');
  filter: ~'ms:alwaysHasItsOwnSyntax.For.Stuff()';
  filter: ~'ms:alwaysHasItsOwnSyntax.For.Stuff()';
}
```

Экранирование с помощью функции `e()` считается устаревшим. Создатели Less предлагают повсеместно внедрять синтаксическую конструкцию `~""` или её аналог с одинарными кавычками.

## Области видимости

Практически во всех языках программирования есть базовые **области видимости** (от англ. scope), представляющие собой область программы, в которой доступно значение объявленной переменной. Если переменная объявлена внутри функции, то её область видимости ограничивается этой функцией, а сама переменная называется _локальной_. Если же переменная объявлена вне функции, то она — _глобальная_.

Less очень похож на язык программирования и так же имеет две области видимости, но с различием в том, что функциями считаются селекторы и примеси. Если переменная объявлена внутри селектора или примеси, то она _локальная_, если нет, то _глобальная_.

Причём Less никак не противится глобальных переменных, наоборот, будет лучше, если все объявленные переменные будут глобальными. Я имею в виду то, что в JavaScript, например, создание лишних глобальных переменных считается роскошью и наказывается. В Less же картина резко противоположная и на то есть весомые причины.

Обычно, в Less переменные хранятся в большом файле с названием `_variables.less`, и вызвано это тем, что так действительно удобнее организовывать хранение, изменение и поддержку актуальности данных. При необходимости разработчик может использовать глобальные переменные где угодно, то есть в любом файле или селекторе. При этом не требуется искать переменные по всем файлам проекта. Разумеется, что речь идёт про редакторы, у которых нет автодополнения переменных.

Свою область видимости в Less создают селекторы, ссылки на родителя селектора (`&`) и примеси.

### Пример 3.1.1

Рассмотрим пример, демонстрирующий работу переменных и области видимости в Less.

Создадим файл `_styles.less` и добавим туда несколько глобальных переменных и селекторов.

```less
// Variables
@body-background: #f5f5f5;
@body-font-size: 14px;

// Code
body {
  background-color: @body-background;
  font-size: @body-font-size;
}

.block {
  @block-color: #333;
  @block-font-size: 28px;

  font-size: @block-font-size;
  color: @block-color;
}

.element {
  font-size: @block-font-size;
}
```

При компиляции возникнет ошибка из-за того, что переменная `@block-font-size` локальная и не может быть использована вне селектора `.block`. При этом глобальные переменные никаких ошибок породить не могут, так как они доступны во всем коде.

```shell
$ lessc _styles.less > styles.css

NameError: variable @block-font-size is undefined in _styles.less on line 20, column 14:

19 .element {
20   font-size: @block-font-size;
21 }
```

## Ленивая загрузка

Переменные в Less настолько ленивые, что их можно объявлять до их непосредственного применения (вызова) и после него. В теории это значит, что переменная инициализируется в точке её вызова, а это значит, что вы можете использовать переменные до того, как вы их объявите.

```less
.lazy {
  width: @lazy-width;
}

@lazy-width: @lazy-height;
@lazy-height: 200px;
```

После компиляции получится следующий код:

```css
.lazy {
  width: 200px;
}
```

Но при таком использовании нужно помнить, что локальные переменные превосходят по важности глобальные. Это правило описано ранее в части «Области видимости». То есть, если использовать две одинаковые по имени переменные, но одна из них будет локальной, а другая глобальной, то все будет зависеть от их места определения и использования.

В этом случае переменная `@lazy-height` будет локальной для объявления селектора `.lazy` и именно её значение будет использоваться при подстановке в `@lazy-width`.

```less
.lazy {
  width: @lazy-width;
  @lazy-height: 100px;
}

@lazy-width: @lazy-height;
@lazy-height: 200px;
```

После компиляции свойству `width` будет присвоено значение `100px`:

```css
.lazy {
  width: 100px;
}
```

Кроме того, в Less, как и в CSS, роль играет последовательность объявления переменных. Имеется в виду, что будет использоваться та переменная, которая объявлена ниже всех.

```less
@element-height: 100px; // 1

.element {
  @element-height: 200px; // 2
  height: @element-height;

  &-footer {
    height: @element-height;
    @element-height: 300px; // 3
    height: @element-height;
    @element-height: 400px; // 4
  }

  @element-height: 500px; // 5
}
```

В этом запутанном блоке кода происходят немыслимые вещи, отображающие всю суть ленивой загрузки. Рассмотрим происходящее более подробно:

- Объявление (1) сразу же можно забыть, так как оно глобальное, а внутри селектора `.element` находятся локальные переменные.
- Локальные объявления (2, 3) тоже можно не учитывать, так как ниже происходит инициализация других переменных.
- Локальное объявление (4) будет использовано внутри объявления `.element-footer`, которое формируется с использованием родительского селектора.
- Локальное объявление (5) будет использовано внутри селектора `.element`.

```css
.element {
  height: 500px;
}
.element-footer {
  height: 400px;
}
```

Не стоит запоминать или заучивать все происходящее в этой части главы, просто будьте уверены, если переменная объявлена ниже всех, то применяться будет именно она. Разумеется, что в рамках её локальности или глобальности.

## Переменные по умолчанию

На основании «ленивой загрузки» в Less предоставляется возможность организации переменных по умолчанию. Возможно, это не такой удобный и явный способ, который предлагает Sass, но, тем не менее, такое практикуется, нужно знать и использовать во благо своих целей.

Ниже приведён код, в котором переопределяется переменная `@color-green`. Получается, что в файле библиотеки вместо глобальной переменной, объявленной внутри неё, будет использована переданная переменная `@color-green` со значением `#003300`.

```less
// Переменные в файле _library.less
@color-green: green;
@color-red: red;

// Импорт библиотеки и переопределенная переменная
@import '_library';
@color-green: #003300;
```

Такое поведение может пригодиться при использовании библиотек или фреймворков, в которых разработчику необходимо переопределить переменные. Но вы должны понимать, что на самом деле значения переменных не изменяются, а происходит та самая «ленивая загрузка».

Переопределение переменных делает настройку структур, таких как Bootstrap 3, более гибкой и простой. Но об этом я расскажу вам в соответствующей главе.
